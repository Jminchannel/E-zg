<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/7_Session/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/7_Session/</url>
    
    <content type="html"><![CDATA[<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/6_Cookie/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/6_Cookie/</url>
    
    <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="Cookie基本使用"><a href="#Cookie基本使用" class="headerlink" title="Cookie基本使用"></a>Cookie基本使用</h2><p>数据保存在<strong>客户端</strong>，每次请求都携带Cookie数据进行访问</p><p><img src="/assets/image-20230902211121274.png" alt="image-20230902211121274"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;zhansan&quot;</span>);<br>    resp.addCookie(cookie);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/image-20230902212437077.png" alt="image-20230902212437077"></p><p><img src="/assets/image-20230902212721661.png" alt="image-20230902212721661"></p><blockquote><p>为什么服务端只能在客户端获取从服务端发送的cookie，而不能获取非服务端发送的其他cookie呢</p></blockquote><p>服务端只能获取从服务端发送的Cookie，以及客户端将这些Cookie随后发送回服务器的Cookie，是由于浏览器的安全性和隐私保护机制所决定的。这个限制有以下原因：</p><ol><li>同源策略：浏览器实施了同源策略（Same-Origin Policy），这是一种安全措施，限制了一个网站（或域）的JavaScript代码只能访问与其来源相同的资源。这意味着，JavaScript代码只能访问与网站的域名相同的Cookie。这是为了防止恶意网站访问用户在其他网站上的Cookie数据。</li><li>安全性：Cookie中包含了敏感信息，如用户身份验证令牌。如果服务端可以直接获取所有Cookie，那么恶意的服务端可以轻松地窃取用户在其他网站上的Cookie信息，导致安全问题。</li><li>隐私保护：Cookie中可能包含用户的隐私信息，如浏览历史、偏好设置等。浏览器将这些信息视为用户的隐私，并严格限制对其访问，以保护用户的隐私。</li></ol><p>虽然服务端不能直接获取非服务端发送的其他网站的Cookie，但可以通过合法的手段，如用户授权或者跳转到其他网站来获取特定Cookie信息。例如，OAuth授权流程允许服务端通过重定向用户到第三方认证提供者的页面，获得用户授权后，获取特定的令牌信息。但这些操作通常需要用户的明示同意和合法的授权机制，以确保隐私和安全。</p><h2 id="Cookie原理"><a href="#Cookie原理" class="headerlink" title="Cookie原理"></a>Cookie原理</h2><ul><li>Cookie的实现是基于HTTP协议的<ul><li>响应头：set-cookie</li><li>请求头：cookie</li></ul></li></ul><p><img src="/assets/image-20230902215325907.png" alt="image-20230902215325907"></p><h2 id="Cookie使用细节"><a href="#Cookie使用细节" class="headerlink" title="Cookie使用细节"></a>Cookie使用细节</h2><ul><li><p>Cookie的存活时间</p><ul><li>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁</li><li>持久化修改：setMaxAge(int seconds)<ol><li>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除</li><li>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</li><li>零：删除对应Cookie</li></ol></li></ul></li><li><p>Cookie存储中文</p><ul><li><p>Cookie不能直接存储中文</p></li><li><p>存储方法：转码，URL编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">encode</span> <span class="hljs-operator">=</span> URLEncoder.encode(value, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;存储数据&quot;</span> + encode);<br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>, encode);<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/5_%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/5_%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h1><p>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中，可以包含多次请求和响应。</p><p><img src="/assets/image-20230902203541003.png" alt="image-20230902203541003"></p><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求之间的数据共享。</p><p><img src="/assets/image-20230902204211410.png" alt="image-20230902204211410"></p><p>HTTP协议是无状态的。每次浏览器向服务器请求数据时，服务器都会以此作为新的请求，因此我们需要会话跟踪技术来实现会话内的数据共享。</p><p>实现方式：</p><ol><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/4_Request&amp;Response/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/4_Request&amp;Response/</url>
    
    <content type="html"><![CDATA[<h1 id="Request-Response"><a href="#Request-Response" class="headerlink" title="Request&amp;&amp;Response"></a>Request&amp;&amp;Response</h1><p><img src="/assets/image-20230902100816161.png" alt="image-20230902100816161"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/demo1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>,<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">&quot;&lt;h1&gt;你好,&quot;</span>+ name + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Request继承体系"><a href="#Request继承体系" class="headerlink" title="Request继承体系"></a>Request继承体系</h3><p><img src="/assets/image-20230902103359677.png" alt="image-20230902103359677"><img src="/assets/image-20230902105751368.png" alt="image-20230902105751368"></p><p>Tomcat解析请求数据，封装为request对象，并且创建request对象传递到service方法中</p><h3 id="Request获取请求数据"><a href="#Request获取请求数据" class="headerlink" title="Request获取请求数据"></a>Request获取请求数据</h3><p>请求数据分为三部分：</p><ol><li><p>请求行：GET&#x2F;requestDemo&#x2F;req?username&#x3D;zhangsan HTTP&#x2F;1.1</p><blockquote><p>String getMethod():获取请求方式：GET<br>String getContextPath():获取虚拟目录（项目访问路径）：&#x2F;requestDemo<br>StringBuffer getRequestURL():获取URL(统一资源定位符)：http:&#x2F;localhost::8080&#x2F;requestDemo&#x2F;req<br>String getRequestURI():(获取URI(统一资源标识符)：&#x2F;requestDemo&#x2F;req<br>String getQueryString():获取请求参数(GET方式)：username&#x3D;zhangsan</p></blockquote></li><li><p>请求头：User-Agent:Mozilla&#x2F;5.0 Chrome&#x2F;91.0.4472.106</p><blockquote><p>String getHeader(String name):根据请求头名称，获取值</p></blockquote></li><li><p>请求体：username&#x3D;zhangsan</p><blockquote><p>ServletInputStream getInputStream()：获取字节输入流</p><p>BufferedReader getReader()：获取字符输入流</p></blockquote></li></ol><h3 id="Request通用方式获取请求参数"><a href="#Request通用方式获取请求参数" class="headerlink" title="Request通用方式获取请求参数"></a>Request通用方式获取请求参数</h3><p><img src="/assets/image-20230902113609955.png" alt="image-20230902113609955"></p><blockquote><p>GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，是否可以提供一种统一获取请求参数的方式，从而统一doGet和doPost方法内的代码？</p></blockquote><p><img src="/assets/image-20230902113849619.png" alt="image-20230902113849619"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/demo1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">//        Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</span><br><span class="hljs-comment">//        for (String key : parameterMap.keySet()) &#123;</span><br><span class="hljs-comment">//            System.out.print(key + &quot;:&quot;);</span><br><span class="hljs-comment">//            String[] strings = parameterMap.get(key);</span><br><span class="hljs-comment">//            Arrays.stream(strings).forEach(System.out::print);</span><br><span class="hljs-comment">//            System.out.println();</span><br><span class="hljs-comment">//        &#125;</span><br>        System.out.println(req.getParameter(<span class="hljs-string">&quot;username&quot;</span>));<br>        System.out.println(req.getParameter(<span class="hljs-string">&quot;password&quot;</span>));<br>        Arrays.stream(req.getParameterValues(<span class="hljs-string">&quot;cb&quot;</span>)).forEach(System.out::print);<br><span class="hljs-comment">//        resp.sendRedirect(&quot;http://www.baidu.com&quot;);</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doGet(req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Request请求参数中文乱码处理"><a href="#Request请求参数中文乱码处理" class="headerlink" title="Request请求参数中文乱码处理"></a>Request请求参数中文乱码处理</h3><p>第一种</p><ol><li>表单方法设置为POST</li><li>在post方法中调用get方法，在get方法中调用<code>req.setCharacterEncoding(&quot;UTF-8&quot;);</code></li></ol><p>第二种</p><p><img src="/assets/image-20230902121809378.png" alt="image-20230902121809378"></p><p>URL编码是将字符串按照编码方式转化为二进制，每个字节转为2个16进制并在前面加上%</p><p><img src="/assets/image-20230902122730170.png" alt="image-20230902122730170"></p><p>浏览器将字符转化为二进制码，（每个字节占8个二进制位）将每个字节转为2个16进制并在前面加上%，即为URL编码，URL编码由浏览器传递到web服务器后，web服务器（Tomcat）将URL以ISO-8859-1进行URL解码，而不是UTF-8，此解码方式无法配置。</p><p>因此解决方案是将web服务器的解码再一次转为二进制数据，再以UTF-8进行URL解码出所需的字符串。</p><h3 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h3><p><img src="/assets/image-20230902141635604.png" alt="image-20230902141635604"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">req.getRequestDispatcher(<span class="hljs-string">&quot;转发路径&quot;</span>).forward(req,resp);<br></code></pre></td></tr></table></figure><p>请求转发资源间共享数据，使用Request对象</p><p><img src="/assets/image-20230902142727072.png" alt="image-20230902142727072"></p><p><img src="/assets/image-20230902143700297.png" alt="image-20230902143700297"></p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><img src="/assets/image-20230902143833545.png" alt="image-20230902143833545"></p><h3 id="Response设置响应数据功能介绍"><a href="#Response设置响应数据功能介绍" class="headerlink" title="Response设置响应数据功能介绍"></a>Response设置响应数据功能介绍</h3><p><img src="/assets/image-20230902144028924.png" alt="image-20230902144028924"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">设置响应状态码：<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> sc)</span></span>;<br>设置响应头键值对: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(<span class="hljs-type">String</span> key,<span class="hljs-type">String</span> value)</span></span>;<br>对响应体：获取字符输出流：<span class="hljs-function">PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span></span>;<br>获取字节输出流：<span class="hljs-function">ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="Response完成重定向"><a href="#Response完成重定向" class="headerlink" title="Response完成重定向"></a>Response完成重定向</h3><p>重定向：一种资源跳转方式</p><p><img src="/assets/image-20230902145600398.png" alt="image-20230902145600398"></p><p><img src="/assets/image-20230902150623532.png" alt="image-20230902150623532"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//        重定向</span><br>        resp.setStatus(<span class="hljs-number">302</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Location&quot;</span>,<span class="hljs-string">&quot;/ReqRespDemo/resp2&quot;</span>);<br><span class="hljs-comment">//        重定向简化</span><br>        resp.sendRedirect(<span class="hljs-string">&quot;/ReqRespDemo/resp2&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>重定向的特点</strong></p><ul><li>浏览器地址栏路径发生变化</li><li>可以重定向到任意位置的资源（服务器内部、外部均可）</li><li>两次请求，不能在多个资源使用request共享数据</li></ul><p><strong>转发的特点</strong></p><ul><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求，可以在转发的资源间使用request共享数据</li></ul><p><strong>路径问题</strong></p><ul><li><strong>明确路径谁使用</strong><ul><li>浏览器使用：需要加虚拟目录（项目访问路径）</li><li>服务器使用：不需要加虚拟目录</li></ul></li></ul><p><img src="/assets/image-20230902164533277.png" alt="image-20230902164533277"></p><ol><li>需要虚拟目录</li><li>需要虚拟目录</li><li>不加虚拟目录</li><li>需要虚拟目录</li></ol><ul><li><strong>动态获取虚拟目录</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-type">String</span> <span class="hljs-variable">contextPath</span> <span class="hljs-operator">=</span> req.getContextPath();<br><span class="hljs-comment">//        重定向简化</span><br>        resp.sendRedirect(contextPath + <span class="hljs-string">&quot;/resp2&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Response响应字符数据"><a href="#Response响应字符数据" class="headerlink" title="Response响应字符数据"></a>Response响应字符数据</h3><p><img src="/assets/image-20230902170253919.png" alt="image-20230902170253919"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 响应头的content-type默认为text/html;charset=ISO-8859-1</span><br>resp.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    resp.getWriter().write(<span class="hljs-string">&quot;&lt;h1&gt;Response3&lt;/h&gt;&quot;</span>);<br>    resp.getWriter().write(<span class="hljs-string">&quot;&lt;h1&gt;你好&lt;/h1&gt;&quot;</span>);<br></code></pre></td></tr></table></figure><p><em>&#x2F;&#x2F;</em>        <em>细节：流不需要手动关闭</em></p><h3 id="Response响应字节数据"><a href="#Response响应字节数据" class="headerlink" title="Response响应字节数据"></a>Response响应字节数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\Employment_Readiness\\黑马-WEB\\ReqRespDemo\\src\\main\\resources\\anya.jpg&quot;</span>));<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>    <span class="hljs-keyword">while</span> ((len = bis.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>        os.write(bytes,<span class="hljs-number">0</span>,len);<br>    &#125;<br>    bis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>字节传输技巧：由工具类commons-io</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IOUtils.copy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\\\Employment_Readiness\\\\黑马-WEB\\\\ReqRespDemo\\\\src\\\\main\\\\resources\\\\anya.jpg&quot;</span>)),resp.getOutputStream());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/3_Servlet/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/3_Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Servlet是Java提供的一门动态web资源开发技术</p><p><img src="/assets/image-20230901085623970.png" alt="image-20230901085623970"></p><p>Servlet是javaee规范之一，其实就一个<strong>接口</strong>，需要我们定义Servlet类的实现类，并由web服务器运行Servlet</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><img src="/assets/image-20230901090339326.png" alt="image-20230901090339326"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;<br>                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;<span class="hljs-number">2.2</span>&lt;/version&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>&lt;/build&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/demo1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello serlvet&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Servlet执行流程"><a href="#Servlet执行流程" class="headerlink" title="Servlet执行流程"></a>Servlet执行流程</h2><p><img src="/assets/image-20230901190907824.png" alt="image-20230901190907824"></p><ol><li>Servlet由谁创建？Servlet方法由谁调用？</li></ol><blockquote><p>答：Tomcat服务器创建和调用。</p></blockquote><ol start="2"><li>服务器如何知道Servlet中一定存在servlet方法？</li></ol><blockquote><p>答：因为我们自定义的Servlet，必须实现Servlet接口并复写其方法，而Servlet接口中有service方法。</p></blockquote><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>对象的生命周期指的是一个对象从被创建到被销毁的整个过程。</p><p><img src="/assets/image-20230901192144902.png" alt="image-20230901192144902"></p><p><img src="/assets/image-20230901192221520.png" alt="image-20230901192221520"></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)</span><span class="hljs-comment">//loadOnStartup为负整数为默认第一次被访问时创建servlet对象。否则为服务器启动时创建Servlet对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * init()初始化方法</span><br><span class="hljs-comment">     * 1.调用时机：默认情况servlet被第一次访问</span><br><span class="hljs-comment">     * 2.调用次数：只调用一次</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> servletConfig</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;init...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提供服务</span><br><span class="hljs-comment">     * 1.调用时机：每次servlet被访问时就会被调用</span><br><span class="hljs-comment">     * 2.调用次数：调用n次</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> servletRequest</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> servletResponse</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;service...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 销毁方法</span><br><span class="hljs-comment">     * 1.调用时机：内存释放的时候或者服务器关闭的时候</span><br><span class="hljs-comment">     * 2.调用次数：1次</span><br><span class="hljs-comment">     * 3.需要通过命令行正常关闭才会调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;destroy()&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Servlet方法介绍"><a href="#Servlet方法介绍" class="headerlink" title="Servlet方法介绍"></a>Servlet方法介绍</h2><p><img src="/assets/image-20230901213656178.png" alt="image-20230901213656178"></p><h2 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h2><p><img src="/assets/image-20230901215512726.png" alt="image-20230901215512726"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">super</span>.doGet(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/image-20230901224351165.png" alt="image-20230901224351165"><img src="/assets/image-20230901224402545.png" alt="image-20230901224402545"></p><ol><li><p>HttpServlet中为什么要根据请求方式的不同，调用不同方法？</p><blockquote><ol><li>继承HttpServlet</li><li>重写doGet()和doPost()</li></ol></blockquote></li><li><p>如何调用？</p><blockquote><p>获取请求方式，并根据不同的请求方式，调用不同的doXxx方法</p></blockquote></li></ol><h2 id="Servlet-urlPattern配置"><a href="#Servlet-urlPattern配置" class="headerlink" title="Servlet urlPattern配置"></a>Servlet urlPattern配置</h2><p>Servlet要被访问，就必须配置访问路径</p><ol><li><p>一个Servlet，可以配置多个urlPattern</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &#123;&quot;/demo1&quot;,&quot;/demo2&quot;,&quot;/demo3&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>urlServlet配置规则</p><ol><li><p>精确匹配</p><p><img src="/assets/image-20230902001851846.png" alt="image-20230902001851846"></p></li><li><p>目录匹配</p><p><img src="/assets/image-20230902001934015.png" alt="image-20230902001934015"></p></li><li><p>扩展名匹配</p><p><img src="/assets/image-20230902002039156.png" alt="image-20230902002039156"></p></li><li><p>任意匹配</p><p><img src="/assets/image-20230902002050729.png" alt="image-20230902002050729"></p></li></ol></li></ol><p>&#x2F;和&#x2F;*的区别</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs qml">项目中Servlet配置了<span class="hljs-string">&#x27;/&#x27;</span>，会覆盖掉tomcat中的DefaultServlet，当其他的<span class="hljs-built_in">url</span>-pattern都匹配不上时都会走这个Servlet。<br>当我们的项目中配置了<span class="hljs-string">&#x27;/*&#x27;</span>，意味着匹配任意访问路径。<br>DefaultServlet会覆盖项目中的所有静态资源，如果被覆盖，则无法访问静态资源。<br></code></pre></td></tr></table></figure><blockquote><p>优先级：精确路径 &gt; 目录路径 &gt; 扩展名路径 &gt; &#x2F;* &gt; &#x2F; </p></blockquote><h2 id="XML配置方式编写Servlet"><a href="#XML配置方式编写Servlet" class="headerlink" title="XML配置方式编写Servlet"></a>XML配置方式编写Servlet</h2><p><img src="/assets/image-20230902094004848.png" alt="image-20230902094004848"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/2_Apache_Tomcat/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/2_Apache_Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>概念：Tomcat是Apache软件基金会一个核心项目，是一个开源免费的<strong>轻量级Web服务器</strong>，支持Servlet&#x2F;JSP少量JavaEE规范。</p></li><li><p>JavaEE：Java Enterprise Edition Java企业版。包含13项技术规范：</p><p>JDBC,JNDI,EJB,JSP,Servlet,XML,JMS,JAVA IDL,JTS,JTA,JavaMail,JAF</p></li></ul><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol><li>Web服务器的作用？封装HTTP协议操作，简化开发。可将web项目部署到服务器，对外提供网上浏览服务。</li><li>Tomcat是一个轻量级的web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称Web容器，Servlet容器。</li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><img src="/assets/image-20230901080720741.png" alt="image-20230901080720741"><img src="/assets/image-20230901080943294.png" alt="image-20230901080943294"></p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>直接删除目录即可</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>双击bin\startup.bat</p><p><img src="/assets/image-20230901081342172.png" alt="image-20230901081342172"></p><p><img src="/assets/image-20230901081241009.png" alt="image-20230901081241009"></p><p>解决乱码问题:在conf&#x2F;logging.properties</p><p><img src="/assets/image-20230901081725216.png" alt="image-20230901081725216"><img src="/assets/image-20230901081833397.png" alt="image-20230901081833397"></p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><ol><li>直接×掉运行窗口：强制关闭</li><li>bin\shutdown.bat:正常关闭</li><li>Ctrl+C:正常关闭</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改端口号：conf&#x2F;server.xml</p><p><img src="/assets/image-20230901082046824.png" alt="image-20230901082046824"></p><p><img src="/assets/image-20230901082210477.png" alt="image-20230901082210477"></p><p>HTTP默认端口号为80</p><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p><img src="/assets/image-20230901082426150.png" alt="image-20230901082426150"></p><p><img src="/assets/image-20230901082532643.png" alt="image-20230901082532643"></p><h2 id="IDEA创建Maven-web项目"><a href="#IDEA创建Maven-web项目" class="headerlink" title="IDEA创建Maven web项目"></a>IDEA创建Maven web项目</h2><p><img src="/assets/image-20230901082834307.png" alt="image-20230901082834307"></p><p>war打包之后就会在target目录中生成，如下</p><p><img src="/assets/image-20230901082934444.png" alt="image-20230901082934444"></p><p><img src="/assets/image-20230901083425622.png" alt="image-20230901083425622"></p><p>编译后的java字节码文件和resource的资源文件放到WEB-INF的classes目录中，pom.xml依赖坐标对应的jar包会放入WEB-INF的lib目录中</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="/assets/image-20230901083706828.png" alt="image-20230901083706828"></p><p><img src="/assets/image-20230901083746740.png" alt="image-20230901083746740"></p><p><img src="/assets/image-20230901084500747.png" alt="image-20230901084500747"></p><p><img src="/assets/image-20230901084614107.png" alt="image-20230901084614107"></p><p><img src="/assets/image-20230901084633362.png" alt="image-20230901084633362"></p><p><img src="/assets/image-20230901084652060.png" alt="image-20230901084652060"></p><h2 id="IDEA集成本地Tomcat"><a href="#IDEA集成本地Tomcat" class="headerlink" title="IDEA集成本地Tomcat"></a>IDEA集成本地Tomcat</h2><p><img src="/assets/image-20230901084959883.png" alt="image-20230901084959883"></p><p><img src="/assets/image-20230901085453488.png" alt="image-20230901085453488"></p><p><img src="/assets/image-20230901085429942.png" alt="image-20230901085429942"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/1_HTTP/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/1_HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则</p><ol><li>基于TCP协议：面向连接，安全</li><li>基于请求-响应模型的：一次请求对应一次响应</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的。<ul><li>缺点：多次请求间不能共享数据。JAVA中使用会话技术（Cookie，Session）来解决此问题。</li><li>优点：速度快</li></ul></li></ol><h2 id="HTTP-请求数据格式"><a href="#HTTP-请求数据格式" class="headerlink" title="HTTP-请求数据格式"></a>HTTP-请求数据格式</h2><p><img src="/assets/image-20230831230845473.png" alt="image-20230831230845473"><img src="/assets/image-20230831231959008.png" alt="image-20230831231959008"></p><p>请求数据分为3部分：</p><ol><li>请求行：请求数据的第一行，其中GET表示请求方式，表示请求资源路径，HTTP&#x2F;1.1表示协议版本</li><li>请求头：第二行开始，格式为key:value形式。</li><li>请求体：POST请求的最后一部分，存放请求参数</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Host：表示请求的主机名<br><span class="hljs-keyword">User</span>-Agent：浏览器版本，例如Chrome浏览器的标识类似Mozilla/<span class="hljs-number">5.0</span>.<br>Chrome/<span class="hljs-number">79</span>：IE浏览器的标识类似Mozilla/<span class="hljs-number">5.0</span>(Windows NT.)<span class="hljs-keyword">like</span> Gecko;<br>Accept：表示浏览器能接收的资源类型，如<span class="hljs-type">text</span><span class="hljs-comment">/*,image,/*或者*/</span>*表示所有；<br>Accept-<span class="hljs-keyword">Language</span>：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；<br>Accept-<span class="hljs-keyword">Encoding</span>：表示浏览器可以支持的压缩类型，例如gzip,deflate等。<br></code></pre></td></tr></table></figure><h3 id="GET请求和POST请求区别："><a href="#GET请求和POST请求区别：" class="headerlink" title="GET请求和POST请求区别："></a>GET请求和POST请求区别：</h3><ol><li>GET请求请求参数在请求行中，没有请求体。<br>POST请求请求参数在请求体中</li><li>GET请求请求参数大小有限制，POST没有</li></ol><p><img src="/assets/image-20230901072215650.png" alt="image-20230901072215650"></p><p><img src="/assets/image-20230901072253569.png" alt="image-20230901072253569"></p><p><img src="/assets/image-20230901072312125.png" alt="image-20230901072312125"></p><h2 id="HTTP-响应数据格式"><a href="#HTTP-响应数据格式" class="headerlink" title="HTTP-响应数据格式"></a>HTTP-响应数据格式</h2><p><img src="/assets/image-20230901072548757.png" alt="image-20230901072548757"></p><ol><li>响应行：响应数据的第一行。其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述</li><li>响应头：第二行开始，格式为key:value形式</li><li>响应体：最后一部分。存放响应数据</li></ol><blockquote><p>响应行的状态码说明：</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span>xx 响应中<span class="hljs-comment">----临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</span><br><span class="hljs-number">2</span>xx 成功<span class="hljs-comment">----表示请求已经被成功接收，处理已完成</span><br><span class="hljs-number">3</span>xx 重定向<span class="hljs-comment">----重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</span><br><span class="hljs-number">4</span>xx 客户端错误<span class="hljs-comment">----处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。</span><br><span class="hljs-number">5</span>xx 服务器端错误<span class="hljs-comment">----处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</span><br></code></pre></td></tr></table></figure><blockquote><p>常见的响应状态码</p></blockquote><p><img src="/assets/image-20230901074144579.png" alt="image-20230901074144579"></p><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a></p><blockquote><p>常见的HTTP响应头</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">Content</span>-Type:表示该响应内容的类型，例如text/html,image/jpeg;<br><span class="hljs-attribute">Content</span>-Length:表示该响应内容的长度（字节数）<br>Content-Encoding:表示该响应压缩算法，例如gzip;<br>Cache-Control:指示客户端应如何缓存，例如max-age=<span class="hljs-number">300</span> 表示可以最多缓存<span class="hljs-number">300</span>秒<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E5%87%AF%E7%A5%9E%E9%99%8D%E4%B8%B4/kaiGod/"/>
    <url>/2023/09/03/%E5%87%AF%E7%A5%9E%E9%99%8D%E4%B8%B4/kaiGod/</url>
    
    <content type="html"><![CDATA[<h1 id="帅是一种态度"><a href="#帅是一种态度" class="headerlink" title="帅是一种态度"></a>帅是一种态度</h1><h1 id="HANDSOMEBOY"><a href="#HANDSOMEBOY" class="headerlink" title="HANDSOMEBOY"></a>HANDSOMEBOY</h1><p><img src="/assets/image-20230903094856925.png" alt="image-20230903094856925"></p><h1 id="FREEDOMBOY"><a href="#FREEDOMBOY" class="headerlink" title="FREEDOMBOY"></a>FREEDOMBOY</h1><p><img src="/assets/image-20230903094907233.png" alt="image-20230903094907233"></p><h1 id="FASHIONBOY"><a href="#FASHIONBOY" class="headerlink" title="FASHIONBOY"></a>FASHIONBOY</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/1_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/03/1_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><p><strong>1.为什么使用数据库</strong></p><ul><li>持久化：将数据保存到可掉电式存储设备中，在硬盘中“固化”数据</li><li>持久化的主要作用：将内存中的数据存储在关系型数据库中</li></ul><p><img src="/assets/image-20230820175721499.png" alt="image-20230820175721499"></p><p><strong>2.数据库与数据库管理系统</strong></p><p><strong>相关概念</strong></p><ul><li>DB:database <strong>数据库</strong>。即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</li><li>DBMS:<strong>数据库管理系统</strong>。是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</li><li>SQL:<strong>结构化查询语言</strong>。用来与数据库通信的语言。</li></ul><p><strong>二者关系</strong></p><p>数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p><p><strong>常见DBMS</strong></p><ul><li>MYSQL</li><li>ORACLE</li><li>SQLSERVER</li></ul><p><strong>3.MYSQL介绍</strong></p><p><strong>概述</strong></p><p>MYSQL是一个<strong>开放源代码的关系型数据库管理系统</strong></p><p><strong>版本由5.7—-&gt;8.0</strong></p><p><strong>ORACLE与<strong><strong>MYSQL</strong></strong>的选择</strong></p><p>Oracle更适合大型跨国企业的使用，对性能要求以及安全性有更高的要求。</p><p>MySQL由于其体积小、速度快、总体拥有成本低，可处理上干万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库(Facebook,Twitter,YouTube,阿里巴巴&#x2F;蚂蚁金服，去哪儿，美团外卖，腾讯)。</p><p><strong>4.RDBMS与非RDMBS</strong></p><p>使用最多的是RDBMS关系型数据库</p><p><strong>RDBMS</strong></p><p>实质：最古老的数据库类型，<strong>二元关系</strong></p><ul><li>关系型数据库以行列存储数据，这一行列系列组成表TABLE，一组表组成库DATABASE</li><li>表与表之间的数据记录存在关系，关系型数据库就是建立在关系模型基础上的数据库</li><li>SQL是查询语言</li></ul><p>优势</p><ul><li>复杂查询</li><li>事务支持</li></ul><p><strong>非RDBMS(NoSQL)</strong></p><p>实质：RDBMS的阉割版，基于键值对存储数据，性能贼高。通过减少不常用的功能进一步提高性能。</p><p><strong>键值型数据库（如Redis）</strong></p><p><strong>文档型数据库（如MongoDB）…</strong></p><p>NoSQL对SQL做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。</p><p><strong>5.RDBMS设计规则</strong></p><ul><li>关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的(Structured)。</li><li>将数据放到表中，表再放到库中。</li><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中“类”的设计。</li></ul><p><strong>表，记录，字段</strong></p><ul><li>ER模型（entity-relationship，实体-联系）三个主要概念：实体集，属性，联系集</li><li>一个实体集(class)对应于数据库中的一个表(table),一个实体(instance)则对应于数据库表中的一行(row),也称为一条记录(record)。一个属性(attribute)对应于数据库表中的一列(column),也称为一个字段(field)。</li></ul><p>ORM思想 表—java的类 表的数据—类的对象 表的列—类的属性</p><p><strong>表的关联关系</strong></p><p>存在四种</p><ol><li>一对一关联</li><li>一对多关联</li><li>多对多关联</li><li>自我引用</li></ol><p><strong>一对一 one to one</strong></p><p>举例：学生表（学号、姓名、手机号码、班级、系别、身份证号码、家庭住籍贯、紧急联系人…）</p><ul><li><p>拆为两个表</p></li><li><ul><li>基础信息表：学号、姓名、手机号码、班级、系别</li><li>档案信息表：身份证号码、家庭住籍贯、紧急联系人…</li></ul></li><li><p>建表原则</p></li><li><ul><li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。</li><li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li></ul></li></ul><p><strong>一对多 one to many</strong></p><p>举例：客户表和订单表，分类表和商品表，部门表和员工表</p><p><strong>多对多 many to many</strong></p><p>创建第三表，即联接表，将多对多划分为两个一对多关系。</p><ul><li>学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）</li><li>课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介…）</li><li>选课信息表：一个学生可以选多门课，一门课可以被多个学生选择</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="/assets/image-20230820190615531.png" alt="image-20230820190615531"></p><p><img src="/assets/image-20230820190652783.png" alt="image-20230820190652783"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
