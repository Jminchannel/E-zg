<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/8_%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/8_%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/7_Session/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/7_Session/</url>
    
    <content type="html"><![CDATA[<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><ul><li>服务端会话跟踪技术，将数据保存到服务端</li><li>JavaEE提供了HttpSession接口，来实现一次会话的多次请求间数据共享功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/session1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>        session.setAttribute(<span class="hljs-string">&quot;SessionUsername&quot;</span>,<span class="hljs-string">&quot;LiHua&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/session2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>        System.out.println(session.getAttribute(<span class="hljs-string">&quot;SessionUsername&quot;</span>).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h2><ul><li>Session是基于Cookie实现的</li><li><img src="/assets/image-20230903123025455.png" alt="image-20230903123025455"></li></ul><p>我的理解：</p><blockquote><p>客户端浏览器访问&#x2F;demo1请求获取服务端的session，服务端收到请求后，服务端创建了一个session对象，并且该对象拥有唯一的标识id，&#x2F;demo1的数据存放到该session对象中，服务器向客户端浏览器响应，将session标识id作为Cookie发送给客户端浏览器，即set-cookie:JSESSIONID，客户端浏览器将这个Cookie存放到浏览器内存中。当该客户端浏览器再一次访问服务端时携带JSESSIONID，服务端获取到cookie值也就是JSESSIONID，服务端将在内存中查找是否存在匹配的Session对象，如果有则使用，否则创建新的Session对象</p></blockquote><h2 id="Session的使用细节"><a href="#Session的使用细节" class="headerlink" title="Session的使用细节"></a>Session的使用细节</h2><ul><li><p>Session钝化，活化</p><ul><li><p>服务器重启后，Session中的数据是否存在？</p><ul><li><p>钝化：服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中。</p><p><img src="/assets/image-20230903131306044.png" alt="image-20230903131306044"></p></li><li><p>活化：再次启动服务器后，从文件中加载数据到Session中</p></li><li><p>当浏览器关闭后，浏览器的从服务端响应到的Cookie消失，但服务端对应的Session对象仍保留</p></li></ul></li></ul></li><li><p>Session销毁</p><ul><li><p>默认情况下，session对象最后一次调用的30分钟自动销毁</p><p><img src="/assets/image-20230903131929014.png" alt="image-20230903131929014"></p></li><li><p>调用Session对象的invalidate()方法</p></li></ul></li></ul><p><img src="/assets/image-20230903132357992.png" alt="image-20230903132357992"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/6_Cookie/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/6_Cookie/</url>
    
    <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="Cookie基本使用"><a href="#Cookie基本使用" class="headerlink" title="Cookie基本使用"></a>Cookie基本使用</h2><p>数据保存在<strong>客户端</strong>，每次请求都携带Cookie数据进行访问</p><p><img src="/assets/image-20230902211121274.png" alt="image-20230902211121274"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;zhansan&quot;</span>);<br>    resp.addCookie(cookie);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/image-20230902212437077.png" alt="image-20230902212437077"></p><p><img src="/assets/image-20230902212721661.png" alt="image-20230902212721661"></p><blockquote><p>为什么服务端只能在客户端获取从服务端发送的cookie，而不能获取非服务端发送的其他cookie呢</p></blockquote><p>服务端只能获取从服务端发送的Cookie，以及客户端将这些Cookie随后发送回服务器的Cookie，是由于浏览器的安全性和隐私保护机制所决定的。这个限制有以下原因：</p><ol><li>同源策略：浏览器实施了同源策略（Same-Origin Policy），这是一种安全措施，限制了一个网站（或域）的JavaScript代码只能访问与其来源相同的资源。这意味着，JavaScript代码只能访问与网站的域名相同的Cookie。这是为了防止恶意网站访问用户在其他网站上的Cookie数据。</li><li>安全性：Cookie中包含了敏感信息，如用户身份验证令牌。如果服务端可以直接获取所有Cookie，那么恶意的服务端可以轻松地窃取用户在其他网站上的Cookie信息，导致安全问题。</li><li>隐私保护：Cookie中可能包含用户的隐私信息，如浏览历史、偏好设置等。浏览器将这些信息视为用户的隐私，并严格限制对其访问，以保护用户的隐私。</li></ol><p>虽然服务端不能直接获取非服务端发送的其他网站的Cookie，但可以通过合法的手段，如用户授权或者跳转到其他网站来获取特定Cookie信息。例如，OAuth授权流程允许服务端通过重定向用户到第三方认证提供者的页面，获得用户授权后，获取特定的令牌信息。但这些操作通常需要用户的明示同意和合法的授权机制，以确保隐私和安全。</p><h2 id="Cookie原理"><a href="#Cookie原理" class="headerlink" title="Cookie原理"></a>Cookie原理</h2><ul><li>Cookie的实现是基于HTTP协议的<ul><li>响应头：set-cookie</li><li>请求头：cookie</li></ul></li></ul><p><img src="/assets/image-20230902215325907.png" alt="image-20230902215325907"></p><h2 id="Cookie使用细节"><a href="#Cookie使用细节" class="headerlink" title="Cookie使用细节"></a>Cookie使用细节</h2><ul><li><p>Cookie的存活时间</p><ul><li>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁</li><li>持久化修改：setMaxAge(int seconds)<ol><li>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除</li><li>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</li><li>零：删除对应Cookie</li></ol></li></ul></li><li><p>Cookie存储中文</p><ul><li><p>Cookie不能直接存储中文</p></li><li><p>存储方法：转码，URL编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">encode</span> <span class="hljs-operator">=</span> URLEncoder.encode(value, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;存储数据&quot;</span> + encode);<br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>, encode);<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/5_%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/"/>
    <url>/2023/09/03/%E9%BB%91%E9%A9%AC-Web%E6%A0%B8%E5%BF%83/5_%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h1><p>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中，可以包含多次请求和响应。</p><p><img src="/assets/image-20230902203541003.png" alt="image-20230902203541003"></p><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求之间的数据共享。</p><p><img src="/assets/image-20230902204211410.png" alt="image-20230902204211410"></p><p>HTTP协议是无状态的。每次浏览器向服务器请求数据时，服务器都会以此作为新的请求，因此我们需要会话跟踪技术来实现会话内的数据共享。</p><p>实现方式：</p><ol><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%E5%87%AF%E7%A5%9E%E9%99%8D%E4%B8%B4/kaiGod/"/>
    <url>/2023/09/03/%E5%87%AF%E7%A5%9E%E9%99%8D%E4%B8%B4/kaiGod/</url>
    
    <content type="html"><![CDATA[<h1 id="帅是一种态度"><a href="#帅是一种态度" class="headerlink" title="帅是一种态度"></a>帅是一种态度</h1><h1 id="HANDSOMEBOY"><a href="#HANDSOMEBOY" class="headerlink" title="HANDSOMEBOY"></a>HANDSOMEBOY</h1><p><img src="/assets/image-20230903094856925.png" alt="image-20230903094856925"></p><h1 id="FREEDOMBOY"><a href="#FREEDOMBOY" class="headerlink" title="FREEDOMBOY"></a>FREEDOMBOY</h1><p><img src="/assets/image-20230903094907233.png" alt="image-20230903094907233"></p><h1 id="FASHIONBOY"><a href="#FASHIONBOY" class="headerlink" title="FASHIONBOY"></a>FASHIONBOY</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/1_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/09/03/1_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><p><strong>1.为什么使用数据库</strong></p><ul><li>持久化：将数据保存到可掉电式存储设备中，在硬盘中“固化”数据</li><li>持久化的主要作用：将内存中的数据存储在关系型数据库中</li></ul><p><img src="/assets/image-20230820175721499.png" alt="image-20230820175721499"></p><p><strong>2.数据库与数据库管理系统</strong></p><p><strong>相关概念</strong></p><ul><li>DB:database <strong>数据库</strong>。即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</li><li>DBMS:<strong>数据库管理系统</strong>。是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</li><li>SQL:<strong>结构化查询语言</strong>。用来与数据库通信的语言。</li></ul><p><strong>二者关系</strong></p><p>数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p><p><strong>常见DBMS</strong></p><ul><li>MYSQL</li><li>ORACLE</li><li>SQLSERVER</li></ul><p><strong>3.MYSQL介绍</strong></p><p><strong>概述</strong></p><p>MYSQL是一个<strong>开放源代码的关系型数据库管理系统</strong></p><p><strong>版本由5.7—-&gt;8.0</strong></p><p><strong>ORACLE与<strong><strong>MYSQL</strong></strong>的选择</strong></p><p>Oracle更适合大型跨国企业的使用，对性能要求以及安全性有更高的要求。</p><p>MySQL由于其体积小、速度快、总体拥有成本低，可处理上干万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库(Facebook,Twitter,YouTube,阿里巴巴&#x2F;蚂蚁金服，去哪儿，美团外卖，腾讯)。</p><p><strong>4.RDBMS与非RDMBS</strong></p><p>使用最多的是RDBMS关系型数据库</p><p><strong>RDBMS</strong></p><p>实质：最古老的数据库类型，<strong>二元关系</strong></p><ul><li>关系型数据库以行列存储数据，这一行列系列组成表TABLE，一组表组成库DATABASE</li><li>表与表之间的数据记录存在关系，关系型数据库就是建立在关系模型基础上的数据库</li><li>SQL是查询语言</li></ul><p>优势</p><ul><li>复杂查询</li><li>事务支持</li></ul><p><strong>非RDBMS(NoSQL)</strong></p><p>实质：RDBMS的阉割版，基于键值对存储数据，性能贼高。通过减少不常用的功能进一步提高性能。</p><p><strong>键值型数据库（如Redis）</strong></p><p><strong>文档型数据库（如MongoDB）…</strong></p><p>NoSQL对SQL做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。</p><p><strong>5.RDBMS设计规则</strong></p><ul><li>关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的(Structured)。</li><li>将数据放到表中，表再放到库中。</li><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中“类”的设计。</li></ul><p><strong>表，记录，字段</strong></p><ul><li>ER模型（entity-relationship，实体-联系）三个主要概念：实体集，属性，联系集</li><li>一个实体集(class)对应于数据库中的一个表(table),一个实体(instance)则对应于数据库表中的一行(row),也称为一条记录(record)。一个属性(attribute)对应于数据库表中的一列(column),也称为一个字段(field)。</li></ul><p>ORM思想 表—java的类 表的数据—类的对象 表的列—类的属性</p><p><strong>表的关联关系</strong></p><p>存在四种</p><ol><li>一对一关联</li><li>一对多关联</li><li>多对多关联</li><li>自我引用</li></ol><p><strong>一对一 one to one</strong></p><p>举例：学生表（学号、姓名、手机号码、班级、系别、身份证号码、家庭住籍贯、紧急联系人…）</p><ul><li><p>拆为两个表</p></li><li><ul><li>基础信息表：学号、姓名、手机号码、班级、系别</li><li>档案信息表：身份证号码、家庭住籍贯、紧急联系人…</li></ul></li><li><p>建表原则</p></li><li><ul><li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。</li><li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li></ul></li></ul><p><strong>一对多 one to many</strong></p><p>举例：客户表和订单表，分类表和商品表，部门表和员工表</p><p><strong>多对多 many to many</strong></p><p>创建第三表，即联接表，将多对多划分为两个一对多关系。</p><ul><li>学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）</li><li>课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介…）</li><li>选课信息表：一个学生可以选多门课，一门课可以被多个学生选择</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="/assets/image-20230820190615531.png" alt="image-20230820190615531"></p><p><img src="/assets/image-20230820190652783.png" alt="image-20230820190652783"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
